

Level 1
Задание 1
--------------

Какова временная сложность?


void test1(int n)
{
   if (n==1)
      return;
   for (int i=1; i<=n; i++)
       for (int j=1; j<=n; j++)
           System.out.println("*");
           break;
}


Случай, когда break стоит за пределами внешнего цикла, не скомпиллируется.

В остальных двух случаях временная сложность будет равна O(n). 
Поскольку если оператор break стоит только внутри внешнего цикла for, 
то внешний цикл завершится после выполнения первой итерации, а внутренний цикл
выполнит количество итераций === n,поэтому временная сложность этого случая
будет O(n).

Если оператор break стоит внутри вложенного for, то вложенный for завершит 
только один цикл для каждой итерации внешнего for, а внешний цикл
будет продолжать выполняться до тех пор, пока i не достигнет значения n. 
Таким образом, временная сложность кода будет такой же, как и в первом случае
то есть она будет равна O(n).   
 

Задание 2
--------------


void test2(int n)
{
   int a = 0;
for (i = 0; i < n; i++)
   for (j = n; j > i; j--)
       a = a + i + j;   
}


Временная сложность этой функции будет равна O(n^2).
В этом случае у нас есть два вложенных цикла: внешний цикл дает O(n)
и внутреннний цикл дает O(n).





Level 2 

Задание 1
--------------


Кова временная сложность?
void test3(int n)
     int i, j, a = 0;
for (i        i <=n; i   
   for (j = 2; j <=n; j   2)
       a=a+n/2;   
}



Код здесь синтаксически не верен и не скомпиллируется, так что 
не ясно, с чем мы здесь имеем дело. Я не знаю, намеренно это было сделано
или нет. Но в любом случае в зависимости от условий циклов мы 
можем здесь получить разную временную сложность, например O(log n), 
O(sqrt(n)), O(n^2).


Например, если бы условие задания выглядело бы так:

void test3(int n) {
     int i, j, a = 0;
     for (i = 1; i <= n; i++) {
         for (j = 1; j <= n; j += 2) {
             a = a + n / 2;
         }
     }
}
 

то можно было бы посчитать временную сложность этой функции. В данном случае
она была бы равна O(n^2), потому что оба цикла дают O(n), что 
дает в результате O(n^2).




Задание 2
-----------

*void test4(int n)
{
   int a = 0, i = n;
while (i > 0) {
   a += i;
   i /= 2;
}
}



Временная сложность этой функции будет равна O(log n), поскольку здесь 
используется алгоритм бинарного поиска.



